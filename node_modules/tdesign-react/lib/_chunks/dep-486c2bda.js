/**
 * tdesign v0.34.4
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

var defineProperty = require('./dep-a1655de1.js');
var slicedToArray = require('./dep-3cf9becb.js');
var React = require('react');
var classNames = require('classnames');
var dayjs = require('dayjs');
var _baseGetTag = require('./dep-fcf32c81.js');
var debounce = require('./dep-85b3eaa4.js');
var toString$1 = require('./dep-86abec96.js');
var _stringToArray = require('./dep-d4a0b3f0.js');
var _baseProperty = require('./dep-837b19c6.js');
var toInteger$1 = require('./dep-d97f1281.js');
var _isIterateeCall = require('./dep-c6637e11.js');
var _util_useConfig = require('../_util/useConfig.js');
var _util_noop = require('../_util/noop.js');
var timePicker_hooks_useTimePickerTextConfig = require('../time-picker/hooks/useTimePickerTextConfig.js');
var _common_js_timePicker_const = require('../_common/js/time-picker/const.js');
var _common_js_timePicker_utils = require('../_common/js/time-picker/utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);
var dayjs__default = /*#__PURE__*/_interopDefaultLegacy(dayjs);

var customParseFormat$1 = {exports: {}};

(function (module, exports) {
  !function (t, e) {
    module.exports = e() ;
  }(_baseGetTag.commonjsGlobal, function () {

    var t = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    },
        e = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
        n = /\d\d/,
        r = /\d\d?/,
        i = /\d*[^\s\d-_:/()]+/,
        o = {},
        s = function s(t) {
      return (t = +t) + (t > 68 ? 1900 : 2e3);
    };

    var a = function a(t) {
      return function (e) {
        this[t] = +e;
      };
    },
        f = [/[+-]\d\d:?(\d\d)?|Z/, function (t) {
      (this.zone || (this.zone = {})).offset = function (t) {
        if (!t) return 0;
        if ("Z" === t) return 0;
        var e = t.match(/([+-]|\d\d)/g),
            n = 60 * e[1] + (+e[2] || 0);
        return 0 === n ? 0 : "+" === e[0] ? -n : n;
      }(t);
    }],
        u = function u(t) {
      var e = o[t];
      return e && (e.indexOf ? e : e.s.concat(e.f));
    },
        h = function h(t, e) {
      var n,
          r = o.meridiem;

      if (r) {
        for (var i = 1; i <= 24; i += 1) {
          if (t.indexOf(r(i, 0, e)) > -1) {
            n = i > 12;
            break;
          }
        }
      } else n = t === (e ? "pm" : "PM");

      return n;
    },
        d = {
      A: [i, function (t) {
        this.afternoon = h(t, !1);
      }],
      a: [i, function (t) {
        this.afternoon = h(t, !0);
      }],
      S: [/\d/, function (t) {
        this.milliseconds = 100 * +t;
      }],
      SS: [n, function (t) {
        this.milliseconds = 10 * +t;
      }],
      SSS: [/\d{3}/, function (t) {
        this.milliseconds = +t;
      }],
      s: [r, a("seconds")],
      ss: [r, a("seconds")],
      m: [r, a("minutes")],
      mm: [r, a("minutes")],
      H: [r, a("hours")],
      h: [r, a("hours")],
      HH: [r, a("hours")],
      hh: [r, a("hours")],
      D: [r, a("day")],
      DD: [n, a("day")],
      Do: [i, function (t) {
        var e = o.ordinal,
            n = t.match(/\d+/);
        if (this.day = n[0], e) for (var r = 1; r <= 31; r += 1) {
          e(r).replace(/\[|\]/g, "") === t && (this.day = r);
        }
      }],
      M: [r, a("month")],
      MM: [n, a("month")],
      MMM: [i, function (t) {
        var e = u("months"),
            n = (u("monthsShort") || e.map(function (t) {
          return t.substr(0, 3);
        })).indexOf(t) + 1;
        if (n < 1) throw new Error();
        this.month = n % 12 || n;
      }],
      MMMM: [i, function (t) {
        var e = u("months").indexOf(t) + 1;
        if (e < 1) throw new Error();
        this.month = e % 12 || e;
      }],
      Y: [/[+-]?\d+/, a("year")],
      YY: [n, function (t) {
        this.year = s(t);
      }],
      YYYY: [/\d{4}/, a("year")],
      Z: f,
      ZZ: f
    };

    function c(n) {
      var r, i;
      r = n, i = o && o.formats;

      for (var s = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (e, n, r) {
        var o = r && r.toUpperCase();
        return n || i[r] || t[r] || i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (t, e, n) {
          return e || n.slice(1);
        });
      })).match(e), a = s.length, f = 0; f < a; f += 1) {
        var u = s[f],
            h = d[u],
            c = h && h[0],
            l = h && h[1];
        s[f] = l ? {
          regex: c,
          parser: l
        } : u.replace(/^\[|\]$/g, "");
      }

      return function (t) {
        for (var e = {}, n = 0, r = 0; n < a; n += 1) {
          var i = s[n];
          if ("string" == typeof i) r += i.length;else {
            var o = i.regex,
                f = i.parser,
                u = t.substr(r),
                h = o.exec(u)[0];
            f.call(e, h), t = t.replace(h, "");
          }
        }

        return function (t) {
          var e = t.afternoon;

          if (void 0 !== e) {
            var n = t.hours;
            e ? n < 12 && (t.hours += 12) : 12 === n && (t.hours = 0), delete t.afternoon;
          }
        }(e), e;
      };
    }

    return function (t, e, n) {
      n.p.customParseFormat = !0, t && t.parseTwoDigitYear && (s = t.parseTwoDigitYear);
      var r = e.prototype,
          i = r.parse;

      r.parse = function (t) {
        var e = t.date,
            r = t.utc,
            s = t.args;
        this.$u = r;
        var a = s[1];

        if ("string" == typeof a) {
          var f = !0 === s[2],
              u = !0 === s[3],
              h = f || u,
              d = s[2];
          u && (d = s[2]), o = this.$locale(), !f && d && (o = n.Ls[d]), this.$d = function (t, e, n) {
            try {
              if (["x", "X"].indexOf(e) > -1) return new Date(("X" === e ? 1e3 : 1) * t);
              var r = c(e)(t),
                  i = r.year,
                  o = r.month,
                  s = r.day,
                  a = r.hours,
                  f = r.minutes,
                  u = r.seconds,
                  h = r.milliseconds,
                  d = r.zone,
                  l = new Date(),
                  m = s || (i || o ? 1 : l.getDate()),
                  M = i || l.getFullYear(),
                  Y = 0;
              i && !o || (Y = o > 0 ? o - 1 : l.getMonth());
              var p = a || 0,
                  v = f || 0,
                  D = u || 0,
                  g = h || 0;
              return d ? new Date(Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1e3)) : n ? new Date(Date.UTC(M, Y, m, p, v, D, g)) : new Date(M, Y, m, p, v, D, g);
            } catch (t) {
              return new Date("");
            }
          }(e, a, r), this.init(), d && !0 !== d && (this.$L = this.locale(d).$L), h && e != this.format(a) && (this.$d = new Date("")), o = {};
        } else if (a instanceof Array) for (var l = a.length, m = 1; m <= l; m += 1) {
          s[1] = a[m - 1];
          var M = n.apply(this, s);

          if (M.isValid()) {
            this.$d = M.$d, this.$L = M.$L, this.init();
            break;
          }

          m === l && (this.$d = new Date(""));
        } else i.call(this, t);
      };
    };
  });
})(customParseFormat$1);

var customParseFormat = customParseFormat$1.exports;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeFloor = Math.floor;
/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */

function baseRepeat$1(string, n) {
  var result = '';

  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  } // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.


  do {
    if (n % 2) {
      result += string;
    }

    n = nativeFloor(n / 2);

    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

var _baseRepeat = baseRepeat$1;

var baseProperty = _baseProperty._baseProperty;
/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

var asciiSize$1 = baseProperty('length');
var _asciiSize = asciiSize$1;

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ = "\\u200d";
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

function unicodeSize$1(string) {
  var result = reUnicode.lastIndex = 0;

  while (reUnicode.test(string)) {
    ++result;
  }

  return result;
}

var _unicodeSize = unicodeSize$1;

var asciiSize = _asciiSize,
    hasUnicode$1 = _stringToArray._hasUnicode,
    unicodeSize = _unicodeSize;
/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */

function stringSize$2(string) {
  return hasUnicode$1(string) ? unicodeSize(string) : asciiSize(string);
}

var _stringSize = stringSize$2;

var baseRepeat = _baseRepeat,
    baseToString = toString$1._baseToString,
    castSlice = _stringToArray._castSlice,
    hasUnicode = _stringToArray._hasUnicode,
    stringSize$1 = _stringSize,
    stringToArray = _stringToArray._stringToArray;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeCeil$1 = Math.ceil;
/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */

function createPadding$1(length, chars) {
  chars = chars === undefined ? ' ' : baseToString(chars);
  var charsLength = chars.length;

  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }

  var result = baseRepeat(chars, nativeCeil$1(length / stringSize$1(chars)));
  return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
}

var _createPadding = createPadding$1;

var createPadding = _createPadding,
    stringSize = _stringSize,
    toInteger = toInteger$1.toInteger_1,
    toString = toString$1.toString_1;
/**
 * Pads `string` on the left side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padStart('abc', 6);
 * // => '   abc'
 *
 * _.padStart('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padStart('abc', 3);
 * // => 'abc'
 */

function padStart(string, length, chars) {
  string = toString(string);
  length = toInteger(length);
  var strLength = length ? stringSize(string) : 0;
  return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
}

var padStart_1 = padStart;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;
/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */

function baseRange$1(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }

  return result;
}

var _baseRange = baseRange$1;

var baseRange = _baseRange,
    isIterateeCall = _isIterateeCall._isIterateeCall,
    toFinite = toInteger$1.toFinite_1;
/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */

function createRange$1(fromRight) {
  return function (start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    } // Ensure the sign of `-0` is preserved.


    start = toFinite(start);

    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }

    step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

var _createRange = createRange$1;

var createRange = _createRange;
/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */

var range = createRange();
var range_1 = range;

var timeArr = [_common_js_timePicker_const.EPickerCols.hour, _common_js_timePicker_const.EPickerCols.minute, _common_js_timePicker_const.EPickerCols.second];
dayjs__default["default"].extend(customParseFormat);

var SinglePanel = function SinglePanel(props) {
  var steps = props.steps,
      format = props.format,
      _props$onChange = props.onChange,
      onChange = _props$onChange === void 0 ? _util_noop["default"] : _props$onChange,
      value = props.value,
      _props$hideDisabledTi = props.hideDisabledTime,
      hideDisabledTime = _props$hideDisabledTi === void 0 ? true : _props$hideDisabledTi,
      disableTime = props.disableTime,
      _props$position = props.position,
      position = _props$position === void 0 ? "start" : _props$position;

  var _useConfig = _util_useConfig["default"](),
      classPrefix = _useConfig.classPrefix;

  var TEXT_CONFIG = timePicker_hooks_useTimePickerTextConfig.useTimePickerTextConfig();
  var panelClassName = "".concat(classPrefix, "-time-picker__panel");

  var _useState = React.useState([]),
      _useState2 = slicedToArray._slicedToArray(_useState, 2),
      cols = _useState2[0],
      setCols = _useState2[1];

  var colsRef = React.useRef([]);
  var maskRef = React.useRef(null);
  var dayjsValue = React.useMemo(function () {
    var isStepsSet = !!steps.filter(function (v) {
      return v > 1;
    }).length;
    if (value) return dayjs__default["default"](value, format);
    if (isStepsSet) return dayjs__default["default"]().hour(0).minute(0).second(0);
    return dayjs__default["default"]();
  }, [value, format, steps]);
  React.useEffect(function () {
    colsRef.current = colsRef.current.slice(0, cols.length);
  }, [cols]);
  React.useEffect(function () {
    var match = format.match(_common_js_timePicker_const.TIME_FORMAT);

    var _match = slicedToArray._slicedToArray(match, 6),
        startCol = _match[1],
        hourCol = _match[2],
        minuteCol = _match[3],
        secondCol = _match[4],
        endCol = _match[5];

    var meridiem = _common_js_timePicker_const.EPickerCols.meridiem,
        hour = _common_js_timePicker_const.EPickerCols.hour,
        minute = _common_js_timePicker_const.EPickerCols.minute,
        second = _common_js_timePicker_const.EPickerCols.second;
    var renderCol = [startCol && meridiem, hourCol && hour, minuteCol && minute, secondCol && second, endCol && meridiem].filter(function (v) {
      return !!v;
    });
    setCols(renderCol);
  }, [format]);
  var getItemHeight = React.useCallback(function () {
    var _maskRef$current;

    var maskDom = maskRef === null || maskRef === void 0 ? void 0 : (_maskRef$current = maskRef.current) === null || _maskRef$current === void 0 ? void 0 : _maskRef$current.querySelector("div");
    var timeItemTotalHeight = maskDom.offsetHeight + parseInt(getComputedStyle(maskDom).marginTop, 10);
    return timeItemTotalHeight;
  }, []);
  var timeItemCanUsed = React.useCallback(function (col, el) {
    var colIdx = timeArr.indexOf(col);

    if (colIdx !== -1) {
      var _ref, _ref$col;

      var params = [dayjsValue.hour(), dayjsValue.minute(), dayjsValue.second()];
      params[colIdx] = Number(el);
      return !((_ref = disableTime && (disableTime === null || disableTime === void 0 ? void 0 : disableTime.apply(void 0, params.concat([{
        partial: position
      }])))) !== null && _ref !== void 0 && (_ref$col = _ref[col]) !== null && _ref$col !== void 0 && _ref$col.includes(Number(el)));
    }

    return true;
  }, [position, disableTime, dayjsValue]);
  var getColList = React.useCallback(function (col) {
    var count = 0;

    if (timeArr.includes(col)) {
      var colIdx = timeArr.indexOf(col);
      var colStep = steps[colIdx];
      if (col === _common_js_timePicker_const.EPickerCols.hour) count = _common_js_timePicker_const.TWELVE_HOUR_FORMAT.test(format) ? 11 : 23;else count = 59;
      var colList = range_1(0, count + 1, Number(colStep)).map(function (v) {
        return padStart_1(String(v), 2, "0");
      }) || [];
      return hideDisabledTime && !!disableTime ? colList.filter(function (t) {
        var _disableTime, _disableTime$col;

        var params = [dayjsValue.hour(), dayjsValue.minute(), dayjsValue.second()];
        params[colIdx] = Number(t);
        return !(disableTime !== null && disableTime !== void 0 && (_disableTime = disableTime.apply(void 0, params.concat([{
          partial: position
        }]))) !== null && _disableTime !== void 0 && (_disableTime$col = _disableTime[col]) !== null && _disableTime$col !== void 0 && _disableTime$col.includes(Number(t)));
      }) : colList;
    }

    return _common_js_timePicker_const.MERIDIEM_LIST;
  }, [steps, format, hideDisabledTime, dayjsValue, disableTime, position]);
  var getScrollDistance = React.useCallback(function (col, time) {
    if (col === _common_js_timePicker_const.EPickerCols.hour && /[h]{1}/.test(format)) time %= 12;
    var itemIdx = getColList(col).indexOf(padStart_1(String(time), 2, "0"));
    var timeItemTotalHeight = getItemHeight();
    var distance = Math.abs(itemIdx * timeItemTotalHeight + timeItemTotalHeight / 2);
    return distance;
  }, [getItemHeight, getColList, format]);

  var handleScroll = function handleScroll(col, idx) {
    var _colsRef$current$idx;

    var val;
    var formattedVal;
    var scrollTop = (_colsRef$current$idx = colsRef.current[idx]) === null || _colsRef$current$idx === void 0 ? void 0 : _colsRef$current$idx.scrollTop;
    var colStep = Math.abs(Math.round(scrollTop / getItemHeight() + 0.5));
    var meridiem = _common_js_timePicker_const.MERIDIEM_LIST[Math.min(colStep - 1, 1)].toLowerCase();
    if (Number.isNaN(colStep)) colStep = 1;

    if (timeArr.includes(col)) {
      var max = 59;

      if (col === _common_js_timePicker_const.EPickerCols.hour) {
        max = /[h]{1}/.test(format) ? 11 : 23;
      }

      var colIdx = timeArr.indexOf(col);
      var availableArr = range_1(0, max + 1, Number(steps[colIdx]));
      val = _common_js_timePicker_utils.closestLookup(availableArr, Number(getColList(col)[Math.min(colStep - 1, max + 1, availableArr.length - 1)]), Number(steps[colIdx]));
      if (Number.isNaN(val)) val = availableArr[availableArr.length - 1];

      if (col === _common_js_timePicker_const.EPickerCols.hour && cols.includes(_common_js_timePicker_const.EPickerCols.meridiem) && dayjsValue.hour() >= 12) {
        val = Number(val) + 12;
      }
    } else val = meridiem;

    var distance = getScrollDistance(col, val);
    if (!dayjs__default["default"](dayjsValue).isValid()) return;

    if (distance !== scrollTop) {
      if (timeArr.includes(col)) {
        var _dayjsValue$col;

        if (timeItemCanUsed(col, val)) formattedVal = (_dayjsValue$col = dayjsValue[col]) === null || _dayjsValue$col === void 0 ? void 0 : _dayjsValue$col.call(dayjsValue, val).format(format);
      } else {
        var currentHour = dayjsValue.hour();

        if (meridiem === _common_js_timePicker_const.AM && currentHour >= 12) {
          formattedVal = dayjsValue.hour(currentHour - 12).format(format);
        } else if (meridiem === _common_js_timePicker_const.PM && currentHour < 12) {
          formattedVal = dayjsValue.hour(currentHour + 12).format(format);
        }
      }

      onChange(formattedVal);
      var scrollCtrl = colsRef.current[cols.indexOf(col)];
      if (!distance || !scrollCtrl || scrollCtrl.scrollTop === distance) return;
      scrollCtrl.scrollTo({
        top: distance,
        behavior: "smooth"
      });
    }
  };

  var scrollToTime = React.useCallback(function (col, time, idx) {
    var behavior = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "auto";
    var distance = getScrollDistance(col, time);
    var scrollCtrl = colsRef.current[idx];
    if (!distance || !scrollCtrl || scrollCtrl.scrollTop === distance || !timeItemCanUsed(col, time)) return;
    scrollCtrl.scrollTo({
      top: distance,
      behavior: behavior
    });
  }, [getScrollDistance]);

  var handleTimeItemClick = function handleTimeItemClick(col, el) {
    if (!timeItemCanUsed(col, el)) return;

    if (timeArr.includes(col)) {
      var _dayjsValue$col2, _dayjsValue$col3;

      if (col === _common_js_timePicker_const.EPickerCols.hour && dayjsValue.format("a") === _common_js_timePicker_const.PM && cols.includes(_common_js_timePicker_const.EPickerCols.meridiem)) {
        el = Number(el) + 12;
      }

      value ? onChange((_dayjsValue$col2 = dayjsValue[col]) === null || _dayjsValue$col2 === void 0 ? void 0 : _dayjsValue$col2.call(dayjsValue, el).format(format)) : onChange((_dayjsValue$col3 = dayjsValue[col]) === null || _dayjsValue$col3 === void 0 ? void 0 : _dayjsValue$col3.call(dayjsValue, el).format(format));
    } else {
      var currentHour = dayjsValue.hour();

      if (el === _common_js_timePicker_const.AM && currentHour >= 12) {
        onChange(dayjsValue.hour(currentHour - 12).format(format));
      } else if (el === _common_js_timePicker_const.PM && currentHour < 12) {
        onChange(dayjsValue.hour(currentHour + 12).format(format));
      }
    }
  };

  var updateTimeScrollPos = React.useCallback(function () {
    var behavior = value ? "smooth" : "auto";
    var isStepsSet = !!steps.filter(function (v) {
      return v > 1;
    }).length;
    cols.forEach(function (col, idx) {
      if (!isStepsSet || isStepsSet && value) {
        var _dayjsValue$col4;

        scrollToTime(col, timeArr.includes(col) ? (_dayjsValue$col4 = dayjsValue[col]) === null || _dayjsValue$col4 === void 0 ? void 0 : _dayjsValue$col4.call(dayjsValue) : dayjsValue.format("a"), idx, behavior);
      } else {
        var _getColList;

        scrollToTime(col, (_getColList = getColList(col)) === null || _getColList === void 0 ? void 0 : _getColList[0], idx, behavior);
      }
    });
  }, [cols, scrollToTime, dayjsValue, value, steps, getColList]);
  React.useEffect(function () {
    updateTimeScrollPos();
  });
  var isCurrent = React.useCallback(function (col, colItem) {
    var _dayjsValue$col5;

    var colVal;

    if (col === _common_js_timePicker_const.EPickerCols.meridiem) {
      var currentMeridiem = dayjsValue.format("a");
      return currentMeridiem === colItem;
    }

    colVal = (_dayjsValue$col5 = dayjsValue[col]) === null || _dayjsValue$col5 === void 0 ? void 0 : _dayjsValue$col5.call(dayjsValue);

    if (col === _common_js_timePicker_const.EPickerCols.hour && /[h]{1}/.test(format)) {
      colVal %= 12;
    }

    return colVal === Number(colItem);
  }, [format, dayjsValue]);

  function renderScrollCtrl() {
    return cols.map(function (col, idx) {
      return /* @__PURE__ */React__default["default"].createElement("ul", {
        key: "".concat(col, "_").concat(idx),
        ref: function ref(el) {
          return colsRef.current[idx] = el;
        },
        className: "".concat(panelClassName, "-body-scroll"),
        onScroll: debounce.debounce_1(function () {
          return handleScroll(col, idx);
        }, 50)
      }, getColList(col).map(function (el) {
        var _classNames;

        return /* @__PURE__ */React__default["default"].createElement("li", {
          key: el,
          className: classNames__default["default"]("".concat(panelClassName, "-body-scroll-item"), (_classNames = {}, defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-is-disabled"), !timeItemCanUsed(col, el)), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-is-current"), isCurrent(col, el)), _classNames)),
          onClick: function onClick() {
            return handleTimeItemClick(col, el);
          }
        }, timeArr.includes(col) ? _common_js_timePicker_const.TWELVE_HOUR_FORMAT.test(format) && el === "00" ? "12" : el : TEXT_CONFIG[el]);
      }));
    });
  }

  return /* @__PURE__ */React__default["default"].createElement("div", {
    className: "".concat(panelClassName, "-body")
  }, /* @__PURE__ */React__default["default"].createElement("div", {
    className: "".concat(panelClassName, "-body-active-mask"),
    ref: maskRef
  }, cols.map(function (col, idx) {
    return /* @__PURE__ */React__default["default"].createElement("div", {
      key: "".concat(col, "_").concat(idx)
    });
  })), renderScrollCtrl());
};

exports.SinglePanel = SinglePanel;
exports.customParseFormat = customParseFormat;
//# sourceMappingURL=dep-486c2bda.js.map
