/**
 * tdesign v0.34.4
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

var toString = require('./dep-86abec96.js');
var _cacheHas = require('./dep-afd8013f.js');
var _arrayIncludesWith = require('./dep-bb21921b.js');
var _baseUnary = require('./dep-ab43c961.js');
var _baseRest = require('./dep-910dcfa3.js');

var SetCache = _cacheHas._SetCache,
    arrayIncludes = _arrayIncludesWith._arrayIncludes,
    arrayIncludesWith = _arrayIncludesWith._arrayIncludesWith,
    arrayMap$1 = toString._arrayMap,
    baseUnary = _baseUnary._baseUnary,
    cacheHas = _cacheHas._cacheHas;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMin = Math.min;
/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */

function baseIntersection$1(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];

    if (othIndex && iteratee) {
      array = arrayMap$1(array, baseUnary(iteratee));
    }

    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
  }

  array = arrays[0];
  var index = -1,
      seen = caches[0];

  outer: while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
      othIndex = othLength;

      while (--othIndex) {
        var cache = caches[othIndex];

        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
          continue outer;
        }
      }

      if (seen) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

var _baseIntersection = baseIntersection$1;

var isArrayLikeObject = _baseRest.isArrayLikeObject_1;
/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */

function castArrayLikeObject$1(value) {
  return isArrayLikeObject(value) ? value : [];
}

var _castArrayLikeObject = castArrayLikeObject$1;

var arrayMap = toString._arrayMap,
    baseIntersection = _baseIntersection,
    baseRest = _baseRest._baseRest,
    castArrayLikeObject = _castArrayLikeObject;
/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */

var intersection = baseRest(function (arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
});
var intersection_1 = intersection;

exports.intersection_1 = intersection_1;
//# sourceMappingURL=dep-3f9b5113.js.map
