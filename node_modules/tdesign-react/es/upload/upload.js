/**
 * tdesign v0.34.4
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _asyncToGenerator, r as regenerator } from '../_chunks/dep-191c9ee3.js';
import { _ as _defineProperty } from '../_chunks/dep-08260abc.js';
import { _ as _toConsumableArray } from '../_chunks/dep-bd2639ad.js';
import { _ as _slicedToArray } from '../_chunks/dep-744640f5.js';
import React, { forwardRef, useRef, useState, useCallback, useMemo } from 'react';
import { i as isEmpty_1 } from '../_chunks/dep-33f486c3.js';
import '../_chunks/dep-12690e1d.js';
import { _ as _baseGet, a as _isKey, b as _toKey } from '../_chunks/dep-084711a9.js';
import { _ as _baseSet, h as hasIn_1 } from '../_chunks/dep-d8cdbac1.js';
import { i as identity_1 } from '../_chunks/dep-048c506f.js';
import { _ as _SetCache, a as _cacheHas, b as _baseFindIndex } from '../_chunks/dep-b8db0e27.js';
import { _ as _typeof } from '../_chunks/dep-4705ff31.js';
import { f as _Uint8Array, e as _Stack } from '../_chunks/dep-ac0cc4dd.js';
import { _ as _Symbol$1 } from '../_chunks/dep-21baa91f.js';
import { e as eq_1 } from '../_chunks/dep-1b27e5c2.js';
import { _ as _getAllKeys, k as keys_1 } from '../_chunks/dep-f459ac73.js';
import { _ as _getTag } from '../_chunks/dep-0e5e855a.js';
import { i as isArray_1 } from '../_chunks/dep-a1fd625f.js';
import { i as isBuffer$1, a as isTypedArray_1 } from '../_chunks/dep-febf8cf9.js';
import { i as isObjectLike_1 } from '../_chunks/dep-12718f01.js';
import { i as isObject_1 } from '../_chunks/dep-38424935.js';
import '../_chunks/dep-ad150068.js';
import { g as get_1 } from '../_chunks/dep-71b3c60f.js';
import { _ as _baseProperty } from '../_chunks/dep-c739cdde.js';
import { t as toInteger_1 } from '../_chunks/dep-87214e71.js';
import { Dialog } from '../dialog/index.js';
import Dragger from './dragger.js';
import UploadTrigger from './upload-trigger.js';
import Tips from './tips.js';
import xhr from '../_common/js/upload/xhr.js';
import useConfig from '../_util/useConfig.js';
import { useLocaleReceiver } from '../locale/LocalReceiver.js';
import SingleFile from './themes/single-file.js';
import ImageCard from './themes/image-card.js';
import Index from './themes/flow-list/index.js';
import BooleanRender from './boolean-render.js';
import { isSingleFile, urlCreator, finishUpload } from './util.js';
import useControlled from '../hooks/useControlled.js';
import useHandleLimit from './hooks/useSizeLimit.js';
import { uploadDefaultProps } from './defaultProps.js';
import '../_chunks/dep-0e5be0b2.js';
import '../_chunks/dep-074143e4.js';
import '../_chunks/dep-8fb1642c.js';
import '../_chunks/dep-531703d1.js';
import '../_chunks/dep-d5f141ac.js';
import '../_chunks/dep-bcb59ae2.js';
import '../_chunks/dep-863396c0.js';
import '../_chunks/dep-e3ab6b0d.js';
import '../_chunks/dep-cc4f2bae.js';
import '../_chunks/dep-e8f6f682.js';
import '../_chunks/dep-f5ab8a5c.js';
import '../_chunks/dep-6963df41.js';
import '../_chunks/dep-09c318fb.js';
import '../_chunks/dep-43a6fda3.js';
import '../_chunks/dep-5ed520e8.js';
import '../dialog/Dialog.js';
import '../_chunks/dep-8ff4a741.js';
import '../_chunks/dep-60c49e74.js';
import 'tdesign-icons-react';
import '../button/index.js';
import '../button/Button.js';
import 'classnames';
import '../_util/useRipple.js';
import '../_util/useAnimation.js';
import '../_chunks/dep-e3ed7551.js';
import '../_chunks/dep-67009882.js';
import '../locale/zh_CN.js';
import '../_common/js/global-config/locale/zh_CN.js';
import '../config-provider/zh_CN_config.js';
import '../_util/setStyle.js';
import '../_util/dom.js';
import 'raf';
import '../_util/easing.js';
import '../loading/index.js';
import '../loading/Loading.js';
import '../common/Portal.js';
import 'react-dom';
import '../loading/gradient.js';
import '../_common/js/loading/circle-adapter.js';
import '../_common/js/utils/set-style.js';
import '../_common/js/utils/helper.js';
import '../loading/defaultProps.js';
import '../loading/plugin.js';
import './style/css.js';
import '../loading/type.js';
import '../button/defaultProps.js';
import '../button/type.js';
import '../_util/noop.js';
import '../dialog/RenderDialog.js';
import 'react-transition-group';
import '../_util/useLayoutEffect.js';
import '../_util/useDialogEsc.js';
import '../dialog/defaultProps.js';
import '../_util/useSetState.js';
import '../config-provider/index.js';
import '../config-provider/ConfigProvider.js';
import '../dialog/plugin.js';
import '../dialog/type.js';
import './themes/dragger-progress.js';
import './themes/flow-list/img-list.js';
import './themes/flow-list/file-list.js';
import '../_chunks/dep-0db6b692.js';
import '../_chunks/dep-6d2697ef.js';
import '../_chunks/dep-42701b6c.js';

var baseGet$1 = _baseGet,
    baseSet = _baseSet;
/**
 * The base implementation of `_.update`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to update.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */

function baseUpdate$1(object, path, updater, customizer) {
  return baseSet(object, path, updater(baseGet$1(object, path)), customizer);
}

var _baseUpdate = baseUpdate$1;

var identity$1 = identity_1;
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction$1(value) {
  return typeof value == 'function' ? value : identity$1;
}

var _castFunction = castFunction$1;

var baseUpdate = _baseUpdate,
    castFunction = _castFunction;
/**
 * This method is like `_.set` except that accepts `updater` to produce the
 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
 * is invoked with one argument: (value).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
 * console.log(object.a[0].b.c);
 * // => 9
 *
 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
 * console.log(object.x[0].y.z);
 * // => 0
 */

function update(object, path, updater) {
  return object == null ? object : baseUpdate(object, path, castFunction(updater));
}

var update_1 = update;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

function arraySome$1(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

var _arraySome = arraySome$1;

var SetCache = _SetCache,
    arraySome = _arraySome,
    cacheHas = _cacheHas;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays$2;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

function mapToArray$1(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray$1;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

function setToArray$1(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray$1;

var _Symbol = _Symbol$1,
    Uint8Array = _Uint8Array,
    eq = eq_1,
    equalArrays$1 = _equalArrays,
    mapToArray = _mapToArray,
    setToArray = _setToArray;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$2; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

var _equalByTag = equalByTag$1;

var getAllKeys = _getAllKeys;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** Used for built-in method references. */

var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects$1;

var Stack$1 = _Stack,
    equalArrays = _equalArrays,
    equalByTag = _equalByTag,
    equalObjects = _equalObjects,
    getTag = _getTag,
    isArray$1 = isArray_1,
    isBuffer = isBuffer$1.exports,
    isTypedArray = isTypedArray_1;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep$1;

var baseIsEqualDeep = _baseIsEqualDeep,
    isObjectLike = isObjectLike_1;
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}

var _baseIsEqual = baseIsEqual$2;

var Stack = _Stack,
    baseIsEqual$1 = _baseIsEqual;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

var _baseIsMatch = baseIsMatch$1;

var isObject = isObject_1;
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable$2(value) {
  return value === value && !isObject(value);
}

var _isStrictComparable = isStrictComparable$2;

var isStrictComparable$1 = _isStrictComparable,
    keys = keys_1;
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData$1(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }

  return result;
}

var _getMatchData = getMatchData$1;

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function matchesStrictComparable$2(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

var _matchesStrictComparable = matchesStrictComparable$2;

var baseIsMatch = _baseIsMatch,
    getMatchData = _getMatchData,
    matchesStrictComparable$1 = _matchesStrictComparable;
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches$1(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

var _baseMatches = baseMatches$1;

var baseIsEqual = _baseIsEqual,
    get = get_1,
    hasIn = hasIn_1,
    isKey$1 = _isKey,
    isStrictComparable = _isStrictComparable,
    matchesStrictComparable = _matchesStrictComparable,
    toKey$1 = _toKey;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$1(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

var _baseMatchesProperty = baseMatchesProperty$1;

var baseGet = _baseGet;
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep$1(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

var _basePropertyDeep = basePropertyDeep$1;

var baseProperty = _baseProperty,
    basePropertyDeep = _basePropertyDeep,
    isKey = _isKey,
    toKey = _toKey;
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property$1(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

var property_1 = property$1;

var baseMatches = _baseMatches,
    baseMatchesProperty = _baseMatchesProperty,
    identity = identity_1,
    isArray = isArray_1,
    property = property_1;
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee$1(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

var _baseIteratee = baseIteratee$1;

var baseFindIndex = _baseFindIndex,
    baseIteratee = _baseIteratee,
    toInteger = toInteger_1;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */

function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;

  if (!length) {
    return -1;
  }

  var index = fromIndex == null ? 0 : toInteger(fromIndex);

  if (index < 0) {
    index = nativeMax(length + index, 0);
  }

  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

var findIndex_1 = findIndex;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var Upload = /*#__PURE__*/forwardRef(function (props, ref) {
  var _props$method = props.method,
      method = _props$method === void 0 ? "post" : _props$method,
      disabled = props.disabled,
      multiple = props.multiple,
      accept = props.accept,
      draggable = props.draggable,
      placeholder = props.placeholder,
      _props$max = props.max,
      max = _props$max === void 0 ? 0 : _props$max,
      _props$name = props.name,
      name = _props$name === void 0 ? "file" : _props$name,
      _props$theme = props.theme,
      theme = _props$theme === void 0 ? "file" : _props$theme,
      _props$showUploadProg = props.showUploadProgress,
      showUploadProgress = _props$showUploadProg === void 0 ? true : _props$showUploadProg,
      action = props.action,
      tips = props.tips,
      format = props.format,
      data = props.data,
      withCredentials = props.withCredentials,
      _props$autoUpload = props.autoUpload,
      autoUpload = _props$autoUpload === void 0 ? true : _props$autoUpload,
      sizeLimit = props.sizeLimit,
      formatResponse = props.formatResponse,
      beforeUpload = props.beforeUpload,
      onProgress = props.onProgress,
      onSuccess = props.onSuccess,
      onFail = props.onFail,
      onRemove = props.onRemove,
      onDragenter = props.onDragenter,
      onDragleave = props.onDragleave,
      onDrop = props.onDrop,
      onPreview = props.onPreview,
      onSelectChange = props.onSelectChange,
      onCancelUpload = props.onCancelUpload,
      requestMethod = props.requestMethod,
      customDraggerRender = props.customDraggerRender,
      children = props.children;

  var _useControlled = useControlled(props, "files", props.onChange),
      _useControlled2 = _slicedToArray(_useControlled, 2),
      fileList = _useControlled2[0],
      onChange = _useControlled2[1];

  var headers = props.headers;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var _useLocaleReceiver = useLocaleReceiver("upload"),
      _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 2),
      locale = _useLocaleReceiver2[0],
      t = _useLocaleReceiver2[1];

  var uploadRef = useRef();
  var filesRef = useRef(fileList);

  var _useState = useState(""),
      _useState2 = _slicedToArray(_useState, 2),
      errorMsg = _useState2[0],
      setErrorMsg = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      uploading = _useState4[0],
      setUploading = _useState4[1];

  var _useState5 = useState([]),
      _useState6 = _slicedToArray(_useState5, 2),
      toUploadFiles = _useState6[0],
      setToUploadFiles = _useState6[1];

  var showImgDialog = ["image", "image-flow", "custom"].includes(theme);

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      showImg = _useState8[0],
      setShowImg = _useState8[1];

  var _useState9 = useState(""),
      _useState10 = _slicedToArray(_useState9, 2),
      imgURL = _useState10[0],
      setImgURL = _useState10[1];

  var closePreview = useCallback(function () {
    setShowImg(false);
    setImgURL("");
  }, []);
  var handleSizeLimit = useHandleLimit();
  var handlePreviewImg = useCallback(function (file, event) {
    if (!file.url) throw new Error("Error file");
    setImgURL(file.url);
    setShowImg(true);
    onPreview === null || onPreview === void 0 ? void 0 : onPreview({
      file: file,
      e: event
    });
  }, [onPreview]);
  var errorText = t(locale.progress.failText);

  var triggerUpload = function triggerUpload() {
    if (disabled) return;
    uploadRef === null || uploadRef === void 0 ? void 0 : uploadRef.current.click();
  };

  var multiUpdateFileList = function multiUpdateFileList(file) {
    var deleteFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var nextFileList = _toConsumableArray(filesRef.current);

    var fileIndex = nextFileList.findIndex(function (_ref) {
      var uid = _ref.uid;
      return uid === file.uid;
    });

    if (deleteFile) {
      fileIndex !== -1 && nextFileList.splice(fileIndex, 1);
      return nextFileList;
    }

    if (fileIndex === -1) {
      nextFileList.push(file);
    } else {
      nextFileList[fileIndex] = file;
    }

    return nextFileList;
  };

  var getLimitedFiles = function getLimitedFiles() {
    var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var isSingleMode = isSingleFile(multiple, theme);
    var mergedLen = files.length + fileList.length;

    if (isSingleMode) {
      return files.splice(0, 1);
    }

    if (max > 0) {
      var limitedFiles = mergedLen > max ? files.slice(0, max - fileList.length) : files;
      return fileList.concat(limitedFiles);
    }

    return fileList.concat(files);
  };

  var onError = useCallback(function (options) {
    var _res;

    var event = options.event,
        file = options.file,
        response = options.response;
    file.status = "fail";
    var res = response;

    if (typeof formatResponse === "function") {
      res = formatResponse(response, {
        file: file
      });
    }

    setErrorMsg(((_res = res) === null || _res === void 0 ? void 0 : _res.error) || errorText);
    var context = {
      e: event,
      file: file
    };
    var nextFileList = multiUpdateFileList(file, true);
    onChange === null || onChange === void 0 ? void 0 : onChange(nextFileList, {
      trigger: "upload fail"
    });
    onFail === null || onFail === void 0 ? void 0 : onFail(context);
  }, [formatResponse, errorText, onChange, onFail]);
  var singleDraggable = useMemo(function () {
    return (!multiple || ["file", "file-input", "image", "custom"].includes(theme)) && draggable;
  }, [draggable, multiple, theme]);

  var handleSingleRemove = function handleSingleRemove(e) {
    var changeCtx = {
      trigger: "remove"
    };
    setErrorMsg("");
    onChange === null || onChange === void 0 ? void 0 : onChange([], changeCtx);
    onRemove === null || onRemove === void 0 ? void 0 : onRemove({
      e: e
    });
  };

  var handleSuccess = useCallback(function (_ref2) {
    var e = _ref2.e,
        tmpFile = _ref2.file,
        response = _ref2.response;
    var file = tmpFile;
    file.status = "success";
    file.url = response.url || file.url;
    var context = {
      e: e,
      response: response,
      trigger: "upload-success"
    };
    var nextFileList = multiUpdateFileList(file);
    var sContext = {
      file: file,
      fileList: nextFileList,
      e: e,
      response: response
    };
    setToUploadFiles(function (toUploadFiles2) {
      return toUploadFiles2.filter(function (toUploadFile) {
        return toUploadFile.name !== file.name;
      });
    });
    onChange === null || onChange === void 0 ? void 0 : onChange(nextFileList, context);
    onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(sContext);
  }, [onChange, onSuccess]);
  var handleProgress = useCallback(function (_ref3) {
    var e = _ref3.e,
        file = _ref3.file,
        percent = _ref3.percent,
        _ref3$type = _ref3.type,
        type = _ref3$type === void 0 ? "mock" : _ref3$type;

    var tmpFile = _objectSpread({}, file);

    tmpFile.percent = percent;
    var progressCtx = {
      percent: percent,
      e: e,
      file: tmpFile,
      type: type
    };
    var nextFileList = multiUpdateFileList(tmpFile);
    onChange === null || onChange === void 0 ? void 0 : onChange(nextFileList, {
      trigger: "progress"
    });
    onProgress === null || onProgress === void 0 ? void 0 : onProgress(progressCtx);
  }, [onChange, onProgress]);
  var handleRequestMethod = useCallback(function (file) {
    if (typeof requestMethod !== "function") {
      console.warn("TDesign Upload Warn: `requestMethod` must be a function.");
      return;
    }

    requestMethod(file).then(function (res) {
      if (!handleRequestMethodResponse(res)) return;

      if (res.status === "success") {
        return handleSuccess({
          file: file,
          response: res.response
        });
      }

      if (res.status === "fail") {
        var r = res.response || {};
        onError({
          file: file,
          response: _objectSpread(_objectSpread({}, r), {}, {
            error: res.error
          })
        });
      }
    });
  }, [handleSuccess, onError, requestMethod]);
  var upload = useCallback( /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(uploadFile) {
      var file;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              file = _objectSpread({}, uploadFile);

              if (!(file.status !== "waiting")) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              if (!(!action && !requestMethod)) {
                _context.next = 6;
                break;
              }

              console.error("TDesign Upload Error: action or requestMethod is required.");
              return _context.abrupt("return");

            case 6:
              setErrorMsg("");
              file.status = "progress";

              if (!requestMethod) {
                _context.next = 10;
                break;
              }

              return _context.abrupt("return", handleRequestMethod(file));

            case 10:
              file.xhr = xhr({
                method: method,
                action: action,
                data: data,
                file: file,
                files: [file],
                name: name,
                onError: onError,
                headers: headers,
                withCredentials: withCredentials,
                onProgress: handleProgress,
                onSuccess: handleSuccess
              });

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref4.apply(this, arguments);
    };
  }(), [method, action, data, handleProgress, handleRequestMethod, handleSuccess, headers, name, onError, requestMethod, withCredentials]);

  function handleRequestMethodResponse(res) {
    if (!res) {
      console.error("TDesign Upload Error: `requestMethodResponse` is required.");
      return false;
    }

    if (!res.status) {
      console.error("TDesign Upload Error: `requestMethodResponse.status` is missing, which value is `success` or `fail`");
      return false;
    }

    if (!["success", "fail"].includes(res.status)) {
      console.error("TDesign Upload Error: `requestMethodResponse.status` must be `success` or `fail`");
      return false;
    }

    if (res.status === "success" && (!res.response || !res.response.url)) {
      console.warn("TDesign Upload Warn: `requestMethodResponse.response.url` is required, when `status` is `success`");
    }

    return true;
  }

  var formatFiles = function formatFiles() {
    var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return files.map(function (fileRaw) {
      var _urlCreator;

      var file = typeof format === "function" ? format(fileRaw) : fileRaw;

      var uploadFile = _objectSpread({
        response: void 0,
        url: "",
        raw: fileRaw,
        lastModified: fileRaw.lastModified,
        name: fileRaw.name,
        size: fileRaw.size,
        type: fileRaw.type,
        percent: 0,
        status: "waiting"
      }, file);

      uploadFile.url = (_urlCreator = urlCreator()) === null || _urlCreator === void 0 ? void 0 : _urlCreator.createObjectURL(fileRaw);
      return uploadFile;
    });
  };

  var handleBeforeUpload = function handleBeforeUpload(file) {
    if (typeof beforeUpload === "function") {
      var r = beforeUpload(file);
      if (r instanceof Promise) return r;
      return Promise.resolve(r);
    }

    if (sizeLimit) {
      var _handleSizeLimit = handleSizeLimit(file.size, sizeLimit),
          _handleSizeLimit2 = _slicedToArray(_handleSizeLimit, 2),
          overrideSize = _handleSizeLimit2[0],
          errorMsg2 = _handleSizeLimit2[1];

      setErrorMsg(errorMsg2);
      return Promise.resolve(overrideSize);
    }

    return Promise.resolve(true);
  };

  var uploadFiles = function uploadFiles() {
    var length = fileList.length;
    var count = 0;
    var newFileList = [];
    fileList.forEach(function (uploadFile) {
      handleBeforeUpload(uploadFile).then(function (canUpload) {
        count += 1;

        if (canUpload) {
          newFileList.push(uploadFile);

          if (autoUpload) {
            upload(uploadFile);
          }
        }

        if (count === length) {
          setToUploadFiles(_toConsumableArray( /* @__PURE__ */new Set([].concat(_toConsumableArray(toUploadFiles), newFileList))));
          onChange === null || onChange === void 0 ? void 0 : onChange(newFileList, {
            trigger: "remove"
          });
        }
      });
    });
  };

  var generateUploadFiles = function generateUploadFiles(files) {
    var uploadList = formatFiles(Array.from(files));
    return getLimitedFiles(uploadList);
  };

  var handleChange = function handleChange(event) {
    if (disabled) return;
    var files = event.target.files;
    var uploadFiles2 = generateUploadFiles(files);
    onSelectChange === null || onSelectChange === void 0 ? void 0 : onSelectChange(uploadFiles2);
    uploadRef.current.value = "";
    onChange === null || onChange === void 0 ? void 0 : onChange(uploadFiles2, {
      trigger: "upload"
    });
    setUploading(true);
  };

  var handleDragChange = function handleDragChange(files) {
    if (disabled) return;
    var uploadFiles2 = generateUploadFiles(files);
    onSelectChange === null || onSelectChange === void 0 ? void 0 : onSelectChange(uploadFiles2);
    onChange === null || onChange === void 0 ? void 0 : onChange(uploadFiles2, {
      trigger: "drag"
    });
    setUploading(true);
  };

  var handleDragenter = useCallback(function (e) {
    if (disabled) return;
    onDragenter === null || onDragenter === void 0 ? void 0 : onDragenter({
      e: e
    });
  }, [disabled, onDragenter]);
  var handleDragleave = useCallback(function (e) {
    if (disabled) return;
    onDragleave === null || onDragleave === void 0 ? void 0 : onDragleave({
      e: e
    });
  }, [disabled, onDragleave]);
  var handleDrop = useCallback(function (e) {
    if (disabled) return;
    onDrop === null || onDrop === void 0 ? void 0 : onDrop({
      e: e
    });
  }, [disabled, onDrop]);
  var cancelUpload = useCallback(function () {
    var files = _toConsumableArray(filesRef.current);

    setUploading(false);
    files.forEach(function (file) {
      if (file.xhr && file.status === "progress") {
        file.xhr.abort();
        update_1(file, "status", function () {
          return "waiting";
        });
        update_1(file, "xhr", function () {
          return void 0;
        });
      }
    });
    onCancelUpload === null || onCancelUpload === void 0 ? void 0 : onCancelUpload();
    onChange === null || onChange === void 0 ? void 0 : onChange(files, {
      trigger: "cancelUpload"
    });
    uploadRef.current.value = "";
  }, [onCancelUpload, onChange]);
  var showUploadList = useMemo(function () {
    return multiple && ["file-flow", "image-flow"].includes(theme);
  }, [theme, multiple]);
  var showErrorMsg = useMemo(function () {
    return !showUploadList && !!errorMsg;
  }, [errorMsg, showUploadList]);
  var showTips = useMemo(function () {
    if (theme === "file") {
      var noFile = isEmpty_1(fileList);
      return tips && noFile;
    }

    return Boolean(tips);
  }, [fileList, theme, tips]);
  var handleMultipleRemove = useCallback(function (options) {
    var files = fileList.concat();
    files.splice(options.index, 1);
    onChange === null || onChange === void 0 ? void 0 : onChange(files, {
      trigger: "remove"
    });
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(options);
  }, [fileList, onChange, onRemove]);
  var handleListRemove = useCallback(function (context) {
    var file = context.file;
    var index = findIndex_1(toUploadFiles, function (o) {
      return o.name === file.name;
    });

    if (index >= 0) {
      setToUploadFiles(function (toUploadFiles2) {
        return toUploadFiles2.splice(index, 1);
      });
    } else {
      var index2 = findIndex_1(fileList, function (o) {
        return o.name === file.name;
      });
      handleMultipleRemove({
        e: context.e,
        index: index2
      });
    }
  }, [fileList, handleMultipleRemove, toUploadFiles]);
  var multipleUpload = useCallback(function (fileList2) {
    var _iterator = _createForOfIteratorHelper(fileList2),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var file = _step.value;
        upload(file);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }, [upload]);
  React.useEffect(function () {
    if (uploading) {
      uploadFiles();
    }
  }, [uploading]);
  useMemo(function () {
    var timestamp = Date.now();
    (fileList || []).forEach(function (file, index) {
      if (!file.uid && !Object.isFrozen(file)) {
        file.uid = "td__upload__".concat(timestamp, "_").concat(index, "__");
      }
    });
    var finish = fileList.every(function (file) {
      return finishUpload(file.status);
    });
    setUploading(!finish);
    filesRef.current = fileList;
  }, [fileList]);
  React.useImperativeHandle(ref, function () {
    return {
      upload: uploadRef.current,
      triggerUpload: triggerUpload
    };
  });
  return /* @__PURE__ */React.createElement("div", {
    className: "".concat(classPrefix, "-upload")
  }, /* @__PURE__ */React.createElement("input", {
    ref: uploadRef,
    type: "file",
    disabled: disabled,
    multiple: multiple,
    accept: accept,
    hidden: true,
    onChange: handleChange
  }), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: !draggable && theme === "custom"
  }, /* @__PURE__ */React.createElement(UploadTrigger, {
    onClick: triggerUpload
  }, children)), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: !draggable && ["file", "file-input"].includes(theme)
  }, /* @__PURE__ */React.createElement(SingleFile, {
    file: fileList && fileList[0],
    display: theme,
    placeholder: placeholder,
    onRemove: handleSingleRemove,
    showUploadProgress: showUploadProgress
  }, /* @__PURE__ */React.createElement(UploadTrigger, {
    onClick: triggerUpload
  }))), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: !draggable && theme === "image"
  }, /* @__PURE__ */React.createElement(ImageCard, {
    multiple: multiple,
    max: max,
    onRemove: handleMultipleRemove,
    onTrigger: triggerUpload,
    files: fileList,
    showUploadProgress: showUploadProgress
  })), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: singleDraggable
  }, /* @__PURE__ */React.createElement(Dragger, {
    onChange: handleDragChange,
    onDragenter: handleDragenter,
    onDragleave: handleDragleave,
    onDrop: handleDrop,
    file: fileList && fileList[0],
    display: theme,
    customDraggerRender: customDraggerRender,
    onCancel: cancelUpload,
    onRemove: handleSingleRemove,
    onUpload: function onUpload(file) {
      upload(file);
    },
    onTrigger: triggerUpload
  })), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: showUploadList
  }, /* @__PURE__ */React.createElement(Index, {
    files: fileList,
    placeholder: placeholder,
    toUploadFiles: toUploadFiles,
    remove: handleListRemove,
    showUploadProgress: showUploadProgress,
    upload: multipleUpload,
    cancel: cancelUpload,
    display: theme,
    onImgPreview: handlePreviewImg,
    onChange: handleDragChange,
    onDragenter: handleDragenter,
    onDragleave: handleDragleave
  }, /* @__PURE__ */React.createElement(UploadTrigger, {
    onClick: triggerUpload
  }))), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: showImgDialog
  }, /* @__PURE__ */React.createElement(Dialog, {
    visible: showImg,
    showOverlay: true,
    width: "auto",
    top: "10%",
    className: "".concat(classPrefix, "-upload__dialog"),
    footer: false,
    header: false,
    onClose: closePreview
  }, /* @__PURE__ */React.createElement("p", {
    className: "".concat(classPrefix, "-dialog__dialog-body-img-box")
  }, /* @__PURE__ */React.createElement("img", {
    src: imgURL,
    alt: ""
  })))), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: !errorMsg && showTips
  }, /* @__PURE__ */React.createElement(Tips, null, tips)), /* @__PURE__ */React.createElement(BooleanRender, {
    boolExpression: showErrorMsg
  }, /* @__PURE__ */React.createElement(Tips, {
    type: "error"
  }, errorMsg)));
});
Upload.displayName = "Upload";
Upload.defaultProps = uploadDefaultProps;

export { Upload as default };
//# sourceMappingURL=upload.js.map
