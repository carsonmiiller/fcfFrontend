/**
 * tdesign v0.34.4
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _typeof } from './dep-4705ff31.js';
import { _ as _defineProperty } from './dep-08260abc.js';
import { _ as _slicedToArray } from './dep-744640f5.js';
import React, { useMemo, forwardRef, useState, useRef, useEffect, useImperativeHandle } from 'react';
import { i as isObject_1 } from './dep-38424935.js';
import './dep-12690e1d.js';
import { _ as _copyObject, k as keysIn_1 } from './dep-ac0cc4dd.js';
import { a as _createAssigner } from './dep-e3ed7551.js';
import { a as _apply } from './dep-048c506f.js';
import { a as isPlainObject_1, _ as _baseRest } from './dep-6963df41.js';
import { a as _baseGetTag } from './dep-21baa91f.js';
import { i as isObjectLike_1 } from './dep-12718f01.js';
import { _ as _arrayMap, t as toString_1 } from './dep-e8f6f682.js';
import { e as eq_1 } from './dep-1b27e5c2.js';
import { _ as _isIterateeCall } from './dep-67009882.js';
import { k as keys_1 } from './dep-f459ac73.js';
import { _ as _basePropertyOf } from './dep-9be29560.js';
import { CheckCircleFilledIcon, CloseCircleFilledIcon, ErrorCircleFilledIcon } from 'tdesign-icons-react';
import useConfig from '../_util/useConfig.js';
import { validate, isValueEmpty } from '../form/formModel.js';
import { useFormContext, useFormListContext } from '../form/FormContext.js';
import classNames from 'classnames';
import renderTNode from '../_util/renderTNode.js';
import { formItemDefaultProps } from '../form/defaultProps.js';
import { getDefaultInitialData, ctrlKeyMap } from '../form/useInitialData.js';

var copyObject = _copyObject,
    createAssigner = _createAssigner,
    keysIn = keysIn_1;
/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith$1 = createAssigner(function (object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});
var assignInWith_1 = assignInWith$1;

var baseGetTag = _baseGetTag,
    isObjectLike = isObjectLike_1,
    isPlainObject = isPlainObject_1;
/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError$2(value) {
  if (!isObjectLike(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
}

var isError_1 = isError$2;

var apply = _apply,
    baseRest = _baseRest,
    isError$1 = isError_1;
/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt$1 = baseRest(function (func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError$1(e) ? e : new Error(e);
  }
});
var attempt_1 = attempt$1;

var arrayMap = _arrayMap;
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues$1(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

var _baseValues = baseValues$1;

var eq = eq_1;
/** Used for built-in method references. */

var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn$1(objValue, srcValue, key, object) {
  if (objValue === undefined || eq(objValue, objectProto$1[key]) && !hasOwnProperty$1.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

var _customDefaultsAssignIn = customDefaultsAssignIn$1;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  "\u2028": 'u2028',
  "\u2029": 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar$1(chr) {
  return '\\' + stringEscapes[chr];
}

var _escapeStringChar = escapeStringChar$1;

/** Used to match template delimiters. */
var reInterpolate$2 = /<%=([\s\S]+?)%>/g;
var _reInterpolate = reInterpolate$2;

var basePropertyOf = _basePropertyOf;
/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar$1 = basePropertyOf(htmlEscapes);
var _escapeHtmlChar = escapeHtmlChar$1;

var escapeHtmlChar = _escapeHtmlChar,
    toString$1 = toString_1;
/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape$1(string) {
  string = toString$1(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}

var _escape = escape$1;

/** Used to match template delimiters. */
var reEscape$1 = /<%-([\s\S]+?)%>/g;
var _reEscape = reEscape$1;

/** Used to match template delimiters. */
var reEvaluate$1 = /<%([\s\S]+?)%>/g;
var _reEvaluate = reEvaluate$1;

var escape = _escape,
    reEscape = _reEscape,
    reEvaluate = _reEvaluate,
    reInterpolate$1 = _reInterpolate;
/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings$1 = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate$1,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': escape
    }
  }
};
var templateSettings_1 = templateSettings$1;

var assignInWith = assignInWith_1,
    attempt = attempt_1,
    baseValues = _baseValues,
    customDefaultsAssignIn = _customDefaultsAssignIn,
    escapeStringChar = _escapeStringChar,
    isError = isError_1,
    isIterateeCall = _isIterateeCall,
    keys = keys_1,
    reInterpolate = _reInterpolate,
    templateSettings = templateSettings_1,
    toString = toString_1;
/** Error message constants. */

var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';
/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */

var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }

  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);
  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.

  var sourceURL = hasOwnProperty.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/\s/g, ' ') + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.

  var variable = hasOwnProperty.call(options, 'variable') && options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = attempt(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if (isError(result)) {
    throw result;
  }

  return result;
}

var template_1 = template;

function useFormItemStyle(props) {
  var _classNames, _classNames2;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var className = props.className,
      help = props.help,
      name = props.name,
      successBorder = props.successBorder,
      errorList = props.errorList,
      successList = props.successList,
      layout = props.layout,
      verifyStatus = props.verifyStatus,
      colon = props.colon,
      label = props.label,
      labelWidth = props.labelWidth,
      labelAlign = props.labelAlign,
      requiredMark = props.requiredMark,
      showErrorMessage = props.showErrorMessage,
      innerRules = props.innerRules;
  var renderName = Array.isArray(name) ? name.join("-") : name;
  var helpNode = help && /* @__PURE__ */React.createElement("div", {
    className: "".concat(classPrefix, "-input__help")
  }, renderTNode(help));
  var extraNode = useMemo(function () {
    var extra = null;
    var list = errorList;

    if (showErrorMessage && list && list[0] && list[0].message) {
      extra = /* @__PURE__ */React.createElement("div", {
        className: "".concat(classPrefix, "-input__extra"),
        title: list[0].message
      }, list[0].message);
    } else if (successList.length) {
      extra = /* @__PURE__ */React.createElement("div", {
        className: "".concat(classPrefix, "-input__extra"),
        title: successList[0].message
      }, successList[0].message);
    }

    return extra;
  }, [showErrorMessage, errorList, successList, classPrefix]);
  var formItemClass = classNames(className, "".concat(classPrefix, "-form__item"), (_classNames = {}, _defineProperty(_classNames, "".concat(classPrefix, "-form-item__").concat(renderName), renderName), _defineProperty(_classNames, "".concat(classPrefix, "-form__item-with-help"), helpNode), _defineProperty(_classNames, "".concat(classPrefix, "-form__item-with-extra"), extraNode), _classNames));
  var formItemLabelClass = classNames("".concat(classPrefix, "-form__label"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(classPrefix, "-form__label--required"), requiredMark && innerRules.filter(function (rule) {
    return rule.required;
  }).length > 0), _defineProperty(_classNames2, "".concat(classPrefix, "-form__label--colon"), colon && label), _defineProperty(_classNames2, "".concat(classPrefix, "-form__label--top"), labelAlign === "top" || !labelWidth), _defineProperty(_classNames2, "".concat(classPrefix, "-form__label--left"), labelAlign === "left" && labelWidth), _defineProperty(_classNames2, "".concat(classPrefix, "-form__label--right"), labelAlign === "right" && labelWidth), _classNames2));

  var contentClass = function contentClass() {
    var _classNames4;

    var controlCls = "".concat(classPrefix, "-form__controls");
    if (!showErrorMessage) return controlCls;
    var isSuccess = verifyStatus === VALIDATE_STATUS.SUCCESS;

    if (isSuccess) {
      return classNames(controlCls, "".concat(classPrefix, "-is-success"), _defineProperty({}, "".concat(classPrefix, "-form--success-border"), successBorder));
    }

    var firstErrorType = errorList.length && (errorList[0].type || "error");
    return classNames(controlCls, (_classNames4 = {}, _defineProperty(_classNames4, "".concat(classPrefix, "-is-warning"), firstErrorType === "warning"), _defineProperty(_classNames4, "".concat(classPrefix, "-is-error"), firstErrorType === "error"), _classNames4));
  };

  var labelStyle = {};
  var contentStyle = {};

  if (label && labelWidth && labelAlign !== "top") {
    if (typeof labelWidth === "number") {
      labelStyle = {
        width: "".concat(labelWidth, "px")
      };
      contentStyle = {
        marginLeft: layout !== "inline" ? "".concat(labelWidth, "px") : ""
      };
    } else {
      labelStyle = {
        width: labelWidth
      };
      contentStyle = {
        marginLeft: layout !== "inline" ? labelWidth : ""
      };
    }
  }

  return {
    formItemClass: formItemClass,
    formItemLabelClass: formItemLabelClass,
    contentClass: contentClass,
    labelStyle: labelStyle,
    contentStyle: contentStyle,
    helpNode: helpNode,
    extraNode: extraNode
  };
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var VALIDATE_STATUS = /* @__PURE__ */function (VALIDATE_STATUS2) {
  VALIDATE_STATUS2["TO_BE_VALIDATED"] = "not";
  VALIDATE_STATUS2["SUCCESS"] = "success";
  VALIDATE_STATUS2["FAIL"] = "fail";
  return VALIDATE_STATUS2;
}(VALIDATE_STATUS || {});
var FormItem = /*#__PURE__*/forwardRef(function (props, ref) {
  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var _useFormContext = useFormContext(),
      colon = _useFormContext.colon,
      layout = _useFormContext.layout,
      requiredMarkFromContext = _useFormContext.requiredMark,
      labelAlignFromContext = _useFormContext.labelAlign,
      labelWidthFromContext = _useFormContext.labelWidth,
      showErrorMessageFromContext = _useFormContext.showErrorMessage,
      disabledFromContext = _useFormContext.disabled,
      resetTypeFromContext = _useFormContext.resetType,
      rulesFromContext = _useFormContext.rules,
      statusIconFromContext = _useFormContext.statusIcon,
      errorMessage = _useFormContext.errorMessage,
      formMapRef = _useFormContext.formMapRef,
      onFormItemValueChange = _useFormContext.onFormItemValueChange;

  var _useFormListContext = useFormListContext(),
      formListName = _useFormListContext.name,
      formListRules = _useFormListContext.rules,
      formListMapRef = _useFormListContext.formListMapRef;

  var children = props.children,
      style = props.style,
      label = props.label,
      name = props.name,
      help = props.help,
      initialData = props.initialData,
      className = props.className,
      successBorder = props.successBorder,
      _props$statusIcon = props.statusIcon,
      statusIcon = _props$statusIcon === void 0 ? statusIconFromContext : _props$statusIcon,
      _props$rules = props.rules,
      innerRules = _props$rules === void 0 ? getInnerRules(name, rulesFromContext, formListName, formListRules) : _props$rules,
      _props$labelWidth = props.labelWidth,
      labelWidth = _props$labelWidth === void 0 ? labelWidthFromContext : _props$labelWidth,
      _props$labelAlign = props.labelAlign,
      labelAlign = _props$labelAlign === void 0 ? labelAlignFromContext : _props$labelAlign,
      _props$requiredMark = props.requiredMark,
      requiredMark = _props$requiredMark === void 0 ? requiredMarkFromContext : _props$requiredMark,
      _props$showErrorMessa = props.showErrorMessage,
      showErrorMessage = _props$showErrorMessa === void 0 ? showErrorMessageFromContext : _props$showErrorMessa;

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      errorList = _useState2[0],
      setErrorList = _useState2[1];

  var _useState3 = useState([]),
      _useState4 = _slicedToArray(_useState3, 2),
      successList = _useState4[0],
      setSuccessList = _useState4[1];

  var _useState5 = useState("not"
  /* TO_BE_VALIDATED */
  ),
      _useState6 = _slicedToArray(_useState5, 2),
      verifyStatus = _useState6[0],
      setVerifyStatus = _useState6[1];

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      resetValidating = _useState8[0],
      setResetValidating = _useState8[1];

  var _useState9 = useState(false),
      _useState10 = _slicedToArray(_useState9, 2),
      needResetField = _useState10[0],
      setNeedResetField = _useState10[1];

  var _useState11 = useState(getDefaultInitialData(children, initialData)),
      _useState12 = _slicedToArray(_useState11, 2),
      formValue = _useState12[0],
      setFormValue = _useState12[1];

  var currentFormItemRef = useRef();
  var innerFormItemsRef = useRef([]);
  var shouldValidate = useRef(null);
  var isMounted = useRef(false);

  var _useFormItemStyle = useFormItemStyle({
    className: className,
    help: help,
    name: name,
    successBorder: successBorder,
    errorList: errorList,
    successList: successList,
    layout: layout,
    verifyStatus: verifyStatus,
    colon: colon,
    label: label,
    labelWidth: labelWidth,
    labelAlign: labelAlign,
    requiredMark: requiredMark,
    showErrorMessage: showErrorMessage,
    innerRules: innerRules
  }),
      formItemClass = _useFormItemStyle.formItemClass,
      formItemLabelClass = _useFormItemStyle.formItemLabelClass,
      contentClass = _useFormItemStyle.contentClass,
      labelStyle = _useFormItemStyle.labelStyle,
      contentStyle = _useFormItemStyle.contentStyle,
      helpNode = _useFormItemStyle.helpNode,
      extraNode = _useFormItemStyle.extraNode;

  function getInnerRules(name2, formRules, formListName2, formListRules2) {
    if (Array.isArray(name2)) {
      var _formRules$formListNa;

      var _name = _slicedToArray(name2, 2),
          itemKey = _name[1];

      return (formRules === null || formRules === void 0 ? void 0 : (_formRules$formListNa = formRules[formListName2]) === null || _formRules$formListNa === void 0 ? void 0 : _formRules$formListNa[itemKey]) || (formListRules2 === null || formListRules2 === void 0 ? void 0 : formListRules2[itemKey]) || [];
    }

    return (formRules === null || formRules === void 0 ? void 0 : formRules[name2]) || formListRules2 || [];
  }

  var renderSuffixIcon = function renderSuffixIcon() {
    if (statusIcon === false) return null;

    var resultIcon = function resultIcon(iconSlot) {
      return /* @__PURE__ */React.createElement("span", {
        className: "".concat(classPrefix, "-form__status")
      }, iconSlot);
    };

    var getDefaultIcon = function getDefaultIcon() {
      var iconMap = {
        success: /* @__PURE__ */React.createElement(CheckCircleFilledIcon, {
          size: "25px"
        }),
        error: /* @__PURE__ */React.createElement(CloseCircleFilledIcon, {
          size: "25px"
        }),
        warning: /* @__PURE__ */React.createElement(ErrorCircleFilledIcon, {
          size: "25px"
        })
      };

      if (verifyStatus === "success"
      /* SUCCESS */
      ) {
        return resultIcon(iconMap[verifyStatus]);
      }

      if (errorList && errorList[0]) {
        var type = errorList[0].type || "error";
        return resultIcon(iconMap[type]);
      }

      return null;
    };

    if ( /*#__PURE__*/React.isValidElement(statusIcon)) {
      return resultIcon( /*#__PURE__*/React.cloneElement(statusIcon, _objectSpread({
        style: {
          color: "unset"
        }
      }, statusIcon.props)));
    }

    if (statusIcon === true) {
      return getDefaultIcon();
    }

    return null;
  };

  function validate$1(trigger) {
    if (innerFormItemsRef.current.length) {
      return innerFormItemsRef.current.map(function (innerFormItem) {
        return innerFormItem === null || innerFormItem === void 0 ? void 0 : innerFormItem.validate();
      });
    }

    var rules = trigger === "all" ? innerRules : innerRules.filter(function (item) {
      return (item.trigger || "change") === trigger;
    });
    setResetValidating(true);
    return new Promise(function (resolve) {
      validate(formValue, rules).then(function (r) {
        var filterErrorList = r.filter(function (item) {
          return item.result !== true;
        }).map(function (item) {
          Object.keys(item).forEach(function (key) {
            if (!item.message && errorMessage[key]) {
              var compiled = template_1(errorMessage[key]);
              item.message = compiled({
                name: label,
                validate: item[key]
              });
            }
          });
          return item;
        });
        setErrorList(filterErrorList);
        setSuccessList(r.filter(function (item) {
          return item.result === true && item.message && item.type === "success";
        }));
        var nextVerifyStatus = filterErrorList.length && rules.length ? "fail"
        /* FAIL */
        : "success"
        /* SUCCESS */
        ;

        if (!rules.some(function (rule) {
          return rule.required;
        }) && isValueEmpty(formValue) || !rules.length) {
          nextVerifyStatus = "not"
          /* TO_BE_VALIDATED */
          ;
        }

        setVerifyStatus(nextVerifyStatus);
        needResetField && resetHandler();
        setResetValidating(false);
        resolve(_defineProperty({}, name, !filterErrorList.length ? true : r));
      });
    });
  }

  function handleItemBlur() {
    var filterRules = innerRules.filter(function (item) {
      return item.trigger === "blur";
    });
    filterRules.length && validate$1("blur");
  }

  function getResetValue(resetType) {
    if (resetType === "initial") {
      return getDefaultInitialData(children, initialData);
    }

    var emptyValue = "";

    if (Array.isArray(formValue)) {
      emptyValue = [];
    } else if (isObject_1(formValue)) {
      emptyValue = {};
    }

    return emptyValue;
  }

  function resetField(type) {
    if (typeof name === "undefined") return;
    var resetType = type || resetTypeFromContext;
    var resetValue = getResetValue(resetType);

    if (resetValue !== formValue) {
      shouldValidate.current = false;
    }

    setFormValue(resetValue);

    if (resetValidating) {
      setNeedResetField(true);
    } else {
      resetHandler();
    }
  }

  function resetHandler() {
    setNeedResetField(false);
    setErrorList([]);
    setSuccessList([]);
    setVerifyStatus("not"
    /* TO_BE_VALIDATED */
    );
  }

  function setField(field) {
    var value = field.value,
        status = field.status;

    if (typeof status !== "undefined") {
      shouldValidate.current = false;
      setErrorList([]);
      setSuccessList([]);
      setNeedResetField(false);
      setVerifyStatus(status);
    }

    if (typeof value !== "undefined") {
      setFormValue(value);
    }
  }

  function setValidateMessage(validateMessage) {
    if (!validateMessage || !Array.isArray(validateMessage)) return;

    if (validateMessage.length === 0) {
      setErrorList([]);
      setVerifyStatus("success"
      /* SUCCESS */
      );
      return;
    }

    setErrorList(validateMessage);
    setVerifyStatus("fail"
    /* FAIL */
    );
  }

  useEffect(function () {
    if (!shouldValidate.current || !isMounted.current) {
      isMounted.current = true;
      shouldValidate.current = true;
      return;
    }

    if (typeof name !== "undefined") {
      if (formListName) {
        var formListValue = [];

        if (Array.isArray(name)) {
          var _name2 = _slicedToArray(name, 2),
              index = _name2[0],
              itemKey = _name2[1];

          formListValue[index] = _defineProperty({}, itemKey, formValue);
        } else {
          formListValue[name] = formValue;
        }

        onFormItemValueChange === null || onFormItemValueChange === void 0 ? void 0 : onFormItemValueChange(_defineProperty({}, formListName, formListValue));
      } else if (Array.isArray(name)) {
        var fieldValue = name.reduceRight(function (prev, curr) {
          return _defineProperty({}, curr, prev);
        }, formValue);
        onFormItemValueChange === null || onFormItemValueChange === void 0 ? void 0 : onFormItemValueChange(_objectSpread({}, fieldValue));
      } else {
        onFormItemValueChange === null || onFormItemValueChange === void 0 ? void 0 : onFormItemValueChange(_defineProperty({}, name, formValue));
      }
    }

    var filterRules = innerRules.filter(function (item) {
      return (item.trigger || "change") === "change";
    });
    filterRules.length && validate$1("change");
  }, [formValue]);
  useEffect(function () {
    if (typeof name === "undefined") return;

    if (formListName) {
      formListMapRef.current.set(name, currentFormItemRef);
      return function () {
        formListMapRef.current["delete"](name);
      };
    }

    if (!formMapRef) return;
    formMapRef.current.set(name, currentFormItemRef);
    return function () {
      formMapRef.current["delete"](name);
    };
  }, [name, formListName]);
  var instance = {
    name: name,
    value: formValue,
    setValue: setFormValue,
    setField: setField,
    validate: validate$1,
    resetField: resetField,
    setValidateMessage: setValidateMessage,
    resetValidate: resetHandler
  };
  useImperativeHandle(ref, function () {
    return instance;
  });
  useImperativeHandle(currentFormItemRef, function () {
    return instance;
  });
  return /* @__PURE__ */React.createElement("div", {
    className: formItemClass,
    style: style
  }, label && /* @__PURE__ */React.createElement("div", {
    className: formItemLabelClass,
    style: labelStyle
  }, /* @__PURE__ */React.createElement("label", {
    htmlFor: props === null || props === void 0 ? void 0 : props["for"]
  }, label)), /* @__PURE__ */React.createElement("div", {
    className: contentClass(),
    style: contentStyle
  }, /* @__PURE__ */React.createElement("div", {
    className: "".concat(classPrefix, "-form__controls-content")
  }, React.Children.map(children, function (child, index) {
    if (!child) return null;

    var onChangeFromProps = function onChangeFromProps() {
      return {};
    };

    var onBlurFromProps = function onBlurFromProps() {
      return {};
    };

    var ctrlKey = "value";

    if ( /*#__PURE__*/React.isValidElement(child)) {
      var _objectSpread2;

      if (child.type === FormItem) {
        return /*#__PURE__*/React.cloneElement(child, {
          ref: function ref(el) {
            if (!el) return;
            innerFormItemsRef.current[index] = el;
          }
        });
      }

      if (typeof child.props.onChange === "function") {
        onChangeFromProps = child.props.onChange;
      }

      if (typeof child.props.onBlur === "function") {
        onBlurFromProps = child.props.onBlur;
      }

      if (_typeof(child.type) === "object") {
        ctrlKey = ctrlKeyMap.get(child.type) || "value";
      }

      return /*#__PURE__*/React.cloneElement(child, _objectSpread(_objectSpread({
        disabled: disabledFromContext
      }, child.props), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, ctrlKey, formValue), _defineProperty(_objectSpread2, "onChange", function onChange(value) {
        var _onChangeFromProps;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_onChangeFromProps = onChangeFromProps).call.apply(_onChangeFromProps, [null, value].concat(args));

        setFormValue(value);
      }), _defineProperty(_objectSpread2, "onBlur", function onBlur(value) {
        var _onBlurFromProps;

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        (_onBlurFromProps = onBlurFromProps).call.apply(_onBlurFromProps, [null, value].concat(args));

        handleItemBlur();
      }), _objectSpread2)));
    }

    return child;
  }), renderSuffixIcon()), helpNode, extraNode));
});
FormItem.displayName = "FormItem";
FormItem.defaultProps = formItemDefaultProps;

export { FormItem as F, VALIDATE_STATUS as V, useFormItemStyle as u };
//# sourceMappingURL=dep-41f09e24.js.map
